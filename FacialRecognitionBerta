#USAGE: python facial_68_Landmark.py

import dlib,cv2
import numpy as np

import imutils 

from matplotlib import pyplot as plt 

%matplotlib inline

from google.colab.patches import cv2_imshow


# -----


# This below mehtod will draw all those points which are from 0 to 67 on face one by one.
def drawPoints(image, faceLandmarks, startpoint, endpoint, isClosed=False):
  points = []
  for i in range(startpoint, endpoint+1):
    point = [faceLandmarks.part(i).x, faceLandmarks.part(i).y]
    points.append(point)

  points = np.array(points, dtype=np.int32)
  cv2.polylines(image, [points], isClosed, (255, 200, 0), thickness=2, lineType=cv2.LINE_8)


# -----


# Use this function for 70-points facial landmark detector model
# we are checking if points are exactly equal to 68, then we draw all those points on face one by one
def facePoints(image, faceLandmarks):
    assert(faceLandmarks.num_parts == 68)
    drawPoints(image, faceLandmarks, 0, 16)           # Jaw line
    drawPoints(image, faceLandmarks, 17, 21)          # Left eyebrow
    drawPoints(image, faceLandmarks, 22, 26)          # Right eyebrow
    drawPoints(image, faceLandmarks, 27, 30)          # Nose bridge
    drawPoints(image, faceLandmarks, 30, 35, True)    # Lower nose
    drawPoints(image, faceLandmarks, 36, 41, True)    # Left eye
    drawPoints(image, faceLandmarks, 42, 47, True)    # Right Eye
    drawPoints(image, faceLandmarks, 48, 59, True)    # Outer lip
    drawPoints(image, faceLandmarks, 60, 67, True)    # Inner lip


# -----


# Use this function for 70-points facial landmark detector model
# we are checking if points are exactly equal to 68, then we draw all those points on face one by one
def facePoints(image, faceLandmarks):
    assert(faceLandmarks.num_parts == 68)
   

# -----


def writeFaceLandmarksToLocalFile(faceLandmarks, fileName):
  with open(fileName, 'w') as f:
    for p in faceLandmarks.parts():
      f.write("%s %s\n" %(int(p.x),int(p.y)))

  f.close()


# -----


# location of the model (path of the model).
Model_PATH = "shape_predictor_68_face_landmarks.dat"


# -----


# now from the dlib we are extracting the method get_frontal_face_detector()
# and assign that object result to frontalFaceDetector to detect face from the image with 
# the help of the 68_face_landmarks.dat model
frontalFaceDetector = dlib.get_frontal_face_detector()



# -----


!wget   http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2 # DOWNLOAD LINK

!bunzip2 /content/shape_predictor_68_face_landmarks.dat.bz2



# -----


# Now the dlip shape_predictor class will take model and with the help of that, it will show 
faceLandmarkDetector = dlib.shape_predictor(Model_PATH)


# -----


!wget -O test.jpeg https://images.unsplash.com/photo-1542909168-82c3e7fdca5c?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxzZWFyY2h8Nnx8ZmFjZXxlbnwwfHwwfHw%3D&w=1000&q=80


# -----


# We now reading image on which we applied our face detector
image = "test.jpeg"


# -----


# Now we are reading image using openCV
img = cv2.imread(image)
imageRGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)


# -----


# landmarks of the face image  will be stored in output/image_k.txt
faceLandmarksOuput= "output/image"


# -----


!wget -O test.jpeg https://cdn8.dissolve.com/p/D145_272_002/D145_272_002_1200.jpg


# -----


# Load the cascade
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")


# -----


# Read the input image 
img = cv2.imread('test.jpeg')
imageRGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# Display 
cv2_imshow(img)


# -----


# Convert into grayscale 
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# Display 
cv2_imshow(gray)


# -----


# Now this line will try to detect all faces in an image either 1 or 2 or more faces
allFaces = frontalFaceDetector(imageRGB, 0)


# -----


print("List of all faces detected: ",len(allFaces))

# List to store landmarks of all detected faces
allFacesLandmark = []



# -----


# Below loop we will use to detect all faces one by one and apply landmarks on them

for k in range(0, len(allFaces)):
  # dlib rectangle class will detecting face so that landmark can apply inside of that area
  faceRectangleDlib = dlib.rectangle(int(allFaces[k].left()),int(allFaces[k].top()),
      int(allFaces[k].right()),int(allFaces[k].bottom()))

  # Now we are running loop on every detected face and putting landmark on that with the help of faceLandmarkDetector
  detectedLandmarks = faceLandmarkDetector(imageRGB, faceRectangleDlib)
  
  # count number of landmarks we actually detected on image
  if k==0:
    print("Total number of face landmarks detected ",len(detectedLandmarks.parts()))

  # Svaing the landmark one by one to the output folder
  allFacesLandmark.append(detectedLandmarks)

  # Now finally we drawing landmarks on face
  facePoints(img, detectedLandmarks)

  fileName = faceLandmarksOuput +"_"+ str(k)+ ".csv"
  print("Lanmdark is save into ", fileName)


# -----


# Use this function for any model other than
# 70 points facial_landmark detector model
def facePoints2(image, faceLandmarks, color=(0, 255, 0), radius=4):
    result = image.copy()
    for i in range(68):
        result = cv2.circle(result, (faceLandmarks.part(i).x, faceLandmarks.part(i).y), radius, color, -1)
    return result

circled_image = facePoints2(img, allFacesLandmark[0])


# -----


#Name of the output file
outputNameofImage = "output/image.jpg"
print("Saving output image to", outputNameofImage)
cv2.imwrite(outputNameofImage, circled_image)


# -----


cv2_imshow(circled_image)


# -----


faceLandmarks = allFacesLandmark[0]
for i in range(68):
    print(f'{i}th point coordinates:', faceLandmarks.part(i).x, faceLandmarks.part(i).y)


# -----


16
30
10

#Create an array of object rect which represents the region of interest
rect = [
    [faceLandmarks.part(16).x, faceLandmarks.part(16).y],
    [faceLandmarks.part(30).x, faceLandmarks.part(30).y],
    [faceLandmarks.part(10).x, faceLandmarks.part(10).y],
]
coords = np.array([rect], dtype=np.int32)

#Create a new array filled with zeros, size equal to size of the image to be filtered
mask = np.zeros(circled_image.shape[:2], np.int8)

mask = cv2.fillPoly(mask, [coords], 1)

new_image = circled_image.copy()
new_image[mask==0] = 0

cv2_imshow(new_image)
